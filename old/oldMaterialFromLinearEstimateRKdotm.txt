% ok so the determinant of this is also improperly -1
    % there is a symmetry where we sometimes get an R matrix that points
    % the frustum in the exact opposite of the correct direction and so we
    % need to correct for that... TODO is to detect it to automatically
    % correct for it
    %R = rotx(180) * roty(180) * rotz(180) * R;
    %{
    disp('K');
    disp(K);
    disp('R');
    disp(R);
    %}
    %problem and solution alert! woohoo maybe i just need positive
    % entries in k and so i multiply by the right identity matrix (
    % with negatives ones and ones) on the right of k and left of r
    % and then since it is its own inverse i have changed nothin :)?
    %shitty implementation to make sure it is doing what i want at first

    %{
    disp('should be the same');
    disp(M);
    disp(R*Q);
    %}


    % and then just make it negative. because.
    %R = -R;
    % well actually check whether we got the negative of the desired
    % solution or not.
    % the wrong solution (-R_desired) will have rotated the z axis from
    % pointing into the glitter plane to pointing the other way and so we
    % can just choose whichever matrix rotates the z axis by more
    % we know that the z-axis of the canonical glitter coordinates points
    % out towards the camera and the desired camera z-axis points back
    % towards the glitter plane, and so the z-entry of the rotate z-tester
    % vector (canonical z basis vector) should be negative.


    %{
    if det(R) < 0
        disp('det(R) < 0 rn');
        
        % so if we want a "proper" rotation matrix, we need to make one of
        % the K entries negative... easy enough:
        Iproper = [1 0 0; 0 -1 0; 0 0 1];
        K = K * Iproper;
        R = Iproper * R;

        disp('now det(R) = ');
        disp(det(R));
    end
    %}

    %R = rotx(180) * roty(180) * rotz(180) * R;
    %{
    disp('K');
    disp(K);
    disp('R');
    disp(R);
    %}
    %{
    % weird thing.. an improper rotation matrix (one which rotates and reflects (flips an axis))
    % needs to be avoided (at the very least because of some complaints
    % from matlab functions but perhaps also for some slightly deeper
    % reason involving finding a desirable form of the solution)

    % attempt at fixing: just flip the z axis. gets us back to the desired
    % coordinate system and it's really unclear that we care which way the
    % z axis is going... so if it's improper, just flip it...
    if det(R) < 0
        disp('hereeeee');
        R = R*[-1 0 0; 0 1 0; 0 0 1;];
    end
    % this doesn't work since it just plainly changes the rotation and so
    the results are wrong by a reflection

    % the next thing to try is just flipping an axis of the data being fit
    to... why this would need to happen sometimes is not clear to me now,
    but I will try it 
    %}

    %{
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% if we get determinant -1 in the orthogonal matrix, we need to re-compute
    % the solution matrix but with one of the axes of the input points
    % being flipped (to get a results with a proper rotation matrix 

    if det(R) < 0
        disp('determinant -1, re-running on augmented inputs');
    end
    % known points in world coordinates
    worldSpecs = mostInliersSpecPos; % the characterized, canonical spec positions that correspond to the sparkling specs in the image
    imageSpecs = mostInliersImageSpecPos; % the image coordinates of where we find those specs in this image
    
    % NEW HERE FOR THIS CASE
    % we can't flip two axes (because that is the same set of points up to
    % a proper rotation. so instead we need to flip an odd number of axes, 
    % which we achieve by flipping a single axis.) shouldn't matter from
    % which set we do this, but ill choose a natural-feeling choice which
    % is the z-axis of the world coordinate system

    % ok doing that made me realize this issue could be related to the fact
    % that the worldSpecs are positioned at 0... which leaves some
    % ambiguity about the direction of the z-axis (making it feel to me
    % like there are two symmetrical solutions that exist, but of course a
    % linear system should either have 1 or infinitely many solutions, and
    % so i'm still confused, but anyways going to try now having a neglible
    % but nonzero z-axis entry for the worldspecs and play with its sign to
    % see if this fixes the problem)

    % after that testing the strange behavior now is that either negative
    % or positive entries for the third axis don't affect the orthogonal
    % matrix's determinant (it is still -1 in both cases) which is odd and
    % unfortunate... odd because -1 det means a reflection (improper
    % rotation where rotation and reflection occurs) and so reflecting one
    % of the axes should get us into the other version of the axes and so
    % the reflection should not be needed anymore (and there only two
    % possibilities for the handed-ness of the axes)

    % that seems plainly wrong to me (and less fuzzy but more likely jsut
    % wrong so now trying to see if it is a consequence of a the precision
    % and the solutions that do or don't have reflection are really close
    % together which makes sense since z axis entries are near zero
    for ix=1:size(worldSpecs)
        worldSpecs(ix,3) = 0;
    end
    %{
    for ix=1:size(imageSpecs)
        imageSpecs(ix,1) = imageSpecs(ix,1) * -1;
    end
    %}


    % also, worldFiducials and imageFiducials give the fiducial marker point
    % correspondences
    w = MEAS.XRES;
    h = MEAS.YRES;
    T = reshape(camPosEst,3,1);
    
    % find R and K by solving linear system
    Q = worldSpecs' - T;
    p = imageSpecs';
    % build matrix
    %{
    skewiszero = true;%solve for skew or not
    if skewiszero
        A = [];
        b = [];
        for ix=1:size(p,2)
            q1 = Q(1,ix);
            q2 = Q(2,ix);
            q3 = Q(3,ix);
            px = p(1,ix);
            py = p(2,ix);    
            A(2*ix-1,:) = [-q1 -q3 0 0 0 q1*px q2*px];
            A(2*ix,:) = [0 0 -q1 -q2 -q3 q1*py q2*py];
            b(2*ix-1) = -q3*px;
            b(2*ix) = -q3*py;
        end
        %solve
        x1 = lsqr(A,b');
        x2 = lsqminnorm(A,b');
        x = A \ b';
        M = [x(1) 0 x(2); x(3) x(4) x(5); x(6) x(7) 1];
    else
    %}
    A = [];
    b = [];
    for ix=1:size(p,2)
        q1 = Q(1,ix);
        q2 = Q(2,ix);
        q3 = Q(3,ix);
        px = p(1,ix);
        py = p(2,ix);    
        A(2*ix-1,:) = [-q1 -q2 -q3 0 0 0 q1*px q2*px];
        A(2*ix,:) = [0 0 0 -q1 -q2 -q3 q1*py q2*py];
        b(2*ix-1) = -q3*px;
        b(2*ix) = -q3*py;
    end
    %solve
    %x1 = lsqr(A,b');
    %x2 = lsqminnorm(A,b');
    x = A \ b';
    M = [x(1) x(2) x(3); x(4) x(5) x(6); x(7) x(8) 1];
    Mmatrix = M;
    %% show (before decomposition) the reprojected points to confirm that they make sense
    figure;
    plot(imageSpecs(:,1),imageSpecs(:,2),'gx');hold on;
    title('BEFORE DECOMPOSITION: the original image specs (green) and projected by M specs (red)');
    for ix=1:size(imageSpecs,1)
        projectedSpec = M * (worldSpecs(ix,:)' - T);
        projectedSpec = projectedSpec ./ projectedSpec(3);
        plot(projectedSpec(1),projectedSpec(2),'r+');hold on;
    end
    
    %%
    % getting RQ decomposition using matlab's QR decomp (doesn't have RQ)
    [R,Q] = rq(M);
    %{
    disp('should be the same');
    disp(M);
    disp(R*Q);
    %}
    % so R (upper triangular) is scaled K and Q (orthogonal) is the rotation
    K = R ./ R(3,3);
    R = Q;
    Kbeforefix = K;
    Rbeforefix = R;% ok so the determinant of this is also improperly -1
    % there is a symmetry where we sometimes get an R matrix that points
    % the frustum in the exact opposite of the correct direction and so we
    % need to correct for that... TODO is to detect it to automatically
    % correct for it
    %R = rotx(180) * roty(180) * rotz(180) * R;
    %{
    disp('K');
    disp(K);
    disp('R');
    disp(R);
    %}
    %problem and solution alert! woohoo maybe i just need positive
    % entries in k and so i multiply by the right identity matrix (
    % with negatives ones and ones) on the right of k and left of r
    % and then since it is its own inverse i have changed nothin :)?
    %shitty implementation to make sure it is doing what i want at first
    Icorrection = [1 0 0; 0 1 0; 0 0 1];
    if K(1,1) < 0
        Icorrection(1,1) = -1;
    end
    if K(2,2) < 0
        Icorrection(2,2) = -1;
    end
    if K(3,3) < 0
        Icorrection(3,3) = -1;
    end
    K = K * Icorrection;
    R = Icorrection * R;
    %R = rotx(180) * roty(180) * rotz(180) * R;
    %{
    disp('K');
    disp(K);
    disp('R');
    disp(R);
    %}
    %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %}

    %{
    disp('Rodrigues parameters as estimated by our glitter');
    disp(ourRodrig)
    disp('Rodrigues parameters as estimated by Matlab checkerboard calibration');
    disp(matlabRodrig);
    %}


    %[Q,R] = qr(M);
    
    % way of doing it with search:
    %             errRK(fx,   fy,   s, w, h, r1,   r2,   r3,   p, Pts, T)
    %{
    plottingFigure = figure;
    errFun = @(x) errRK(x(1), x(2), x(3), w, h, x(4), x(5), x(6), imageSpecs,...
        worldSpecs, imageFiducials, worldFiducials, T, plottingFigure);
    %x0 = [10^(-3)*12000 10^(-3)*12000 0 3 -1.5 -1.5]';% old starting guess
    % use the results of the linear system solution to give us the starting
    % guess for the minimization
    x0 = [10^(-3)*K(1,1) 10^(-3)*K(2,2) K(1,2) ourRodrig(1) ourRodrig(2) ourRodrig(3)];
    % use the camera known points for x0 TODO
    options = optimset('PlotFcns',@optimplotfval);
    xf = fminsearch(errFun, x0, options);
    fx = xf(1);
    fy = xf(2);
    s = xf(3);
    r1 = xf(4);
    r2 = xf(5);
    r3 = xf(6);
    R = rodrigues(r1,r2,r3);
    %
    s = 0;
    K = [10^(3)*fx s w/2; 0 10^(3)*fy h/2; 0 0 1];
    disp('and here are the optimized K and R respectively matrices from using initial guess from linear system:');
    disp(K);
    disp(R);
    %}
    %{
    skewiszero = true;%solve for skew or not
    if skewiszero
        A = [];
        b = [];
        for ix=1:size(p,2)
            q1 = Q(1,ix);
            q2 = Q(2,ix);
            q3 = Q(3,ix);
            px = p(1,ix);
            py = p(2,ix);    
            A(2*ix-1,:) = [-q1 -q3 0 0 0 q1*px q2*px];
            A(2*ix,:) = [0 0 -q1 -q2 -q3 q1*py q2*py];
            b(2*ix-1) = -q3*px;
            b(2*ix) = -q3*py;
        end
        %solve
        x1 = lsqr(A,b');
        x2 = lsqminnorm(A,b');
        x = A \ b';
        M = [x(1) 0 x(2); x(3) x(4) x(5); x(6) x(7) 1];
    else
    %}

    
    %{
    %% match canonical centroids to those in the characterization
    knownCanonicalCentroids = matfile(P.canonicalCentroids).canonicalCentroids;
    K = 10;
    [idx, dist] = knnsearch(knownCanonicalCentroids, canonicalCentroids,...
                                 'K', K, 'Distance', 'euclidean');
    % only consider specs whose match is within .xx millimeters
    %closeEnough = .3;
    %specIdxs = idx(dist<closeEnough);
    %specPos = knownCanonicalCentroids(idx,:);
    specPos = zeros(size(idx,1),K,3);
    for ix=1:size(idx,1)
        specPos(ix,:,:) = knownCanonicalCentroids(idx(ix,:),:);
    end
    % draw vector map where each vector goes from a spec to its nearest spec
    % neighbor
    %figure;
    %quiver(canonicalCentroids(:,1), canonicalCentroids(:,2), knownCanonicalCentroids(idx(:,1),1)-canonicalCentroids(:,1), knownCanonicalCentroids(idx(:,1),2)-canonicalCentroids(:,2),'LineWidth',2);
    %x = knownCanonicalCentroids(idx(:,1),1)-canonicalCentroids(:,1);
    %y = knownCanonicalCentroids(idx(:,1),2)-canonicalCentroids(:,2);
    %figure;
    %histogram(atan2(y, x));title('histogram of vector directions');
    %xlabel('direction in radians');
    
    %% get spec normals and brightness
    allSpecNormals = matfile(P.specNormals).specNormals;
    specNormals = zeros(size(idx,1),K,3);
    for ix=1:size(idx,1)
        specNormals(ix,:,:) = allSpecNormals(idx(ix,:),:);
    end
    allMaxBrightness = matfile(P.maxBrightness).maxBrightness;
    maxBrightness = zeros(size(idx,1),K);
    for ix=1:size(idx,1)
        maxBrightness(ix,:) = allMaxBrightness(idx(ix,:));
    end
    %}

    %{
    disp(R);
    disp(T);
    %}
    %pose = rigid3d(R',T');
    %hold on;
    %camObj = plotCamera('AbsolutePose',pose,'Opacity',0,'Size',35);

